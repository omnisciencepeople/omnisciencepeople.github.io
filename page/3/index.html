<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>My Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="My Blog">
<meta property="og:url" content="https://username.github.io/page/3/index.html">
<meta property="og:site_name" content="My Blog">
<meta property="og:locale">
<meta property="article:author" content="omnisciencepeople">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="My Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">My Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://username.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-排序之希尔排序" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/12/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/" class="article-date">
  <time class="dt-published" datetime="2021-03-12T14:46:33.000Z" itemprop="datePublished">2021-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/12/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">排序之希尔排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>希尔排序：是优化了插入排序的排序，又称缩小增量排序；<br>基本思想：先将整个待排记录序列分割成若干个子序列，分别进行插入排序，待整个序列中的记录基本有序时，再对全体记录直<br>接进行一次插入排序；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Shell_sort&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] arr&#x3D;&#123;1,5,2,8,3,9,4,6,5,10,56165,5,5156,515,113,3,35,451,151,3484,51,54,1,14,1,1,351,01,13,131,345,1,346431,4,1,4&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    static void sort(int[] arr)&#123;</span><br><span class="line">        int h&#x3D;1;</span><br><span class="line">        while(h&lt;arr.length&#x2F;3)   </span><br><span class="line">        &#123;</span><br><span class="line">            h&#x3D;3*h+1;</span><br><span class="line">        &#125;&#x2F;&#x2F;求出最大增量</span><br><span class="line">        for(int gap&#x3D;h;gap&gt;0;gap&#x3D;(gap-1)&#x2F;3)&#x2F;&#x2F;不断缩小增量进行插入排序</span><br><span class="line">           for(int i&#x3D;gap;i&lt;arr.length;i++)&#x2F;&#x2F;从gap开始遍历</span><br><span class="line">             for(int j&#x3D;i;j&gt;gap-1&amp;&amp;arr[j]&lt;arr[j-gap];j-&#x3D;gap)&#x2F;&#x2F;希尔排序前面有序，故可这样写</span><br><span class="line">                 swap(arr,j,j-gap);</span><br><span class="line">           print(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    static void print(int[] arr)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;arr.length;i++)</span><br><span class="line">           System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">           System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    static void swap(int[] arr,int i,int j)&#123;</span><br><span class="line">        int temp&#x3D;arr[i];</span><br><span class="line">        arr[i]&#x3D;arr[j];</span><br><span class="line">        arr[j]&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2021/03/12/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/" data-id="ckm6fbis7000070vpg1d6davz" data-title="排序之希尔排序" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java容器程序演示和内容补充" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/12/Java%E5%AE%B9%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%BC%94%E7%A4%BA%E5%92%8C%E5%86%85%E5%AE%B9%E8%A1%A5%E5%85%85/" class="article-date">
  <time class="dt-published" datetime="2021-03-12T08:18:41.000Z" itemprop="datePublished">2021-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/12/Java%E5%AE%B9%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%BC%94%E7%A4%BA%E5%92%8C%E5%86%85%E5%AE%B9%E8%A1%A5%E5%85%85/">Java容器程序演示和内容补充</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class test15&#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">   ArrayList aa&#x3D;new ArrayList();&#x2F;&#x2F;构造一个初始容量为十的空列表。 </span><br><span class="line">   aa.add(12345);&#x2F;&#x2F;12345会被自动封装成相应的Integer对象</span><br><span class="line">   aa.add(&quot;张三&quot;);&#x2F;&#x2F;字符串为一个对象</span><br><span class="line">   aa.add(66.6);&#x2F;&#x2F;66.6会被自动封装成一个Double对象</span><br><span class="line">   aa.add(new A());</span><br><span class="line">   System.out.println(aa);&#x2F;&#x2F;默认调用每个元素的toString方法</span><br><span class="line">   &#x2F;&#x2F;System.out.println(aa[2]);&#x2F;&#x2F;error 容器不是数组</span><br><span class="line">   System.out.println(aa.get(2));&#x2F;&#x2F;调用List中的get方法得到下标为2的元素</span><br><span class="line">   Object[] ob&#x3D;aa.toArray();&#x2F;&#x2F;toArray方法以正确的顺序返回一个包含此列表中所有元素的数组。 </span><br><span class="line">   System.out.println(ob[2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">     public String toString()&#123;</span><br><span class="line">         return &quot;哈哈&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">编译时会产生和泛型相关的错误，可忽略，之后会解决</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>


<p>collections类方法使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class test16&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        List L&#x3D;new LinkedList();</span><br><span class="line">        for(int i&#x3D;0;i&lt;7;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            L.add(&quot;a&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.shuffle(L);&#x2F;&#x2F;将容器内元素随机排列</span><br><span class="line">        System.out.println(L);</span><br><span class="line">        Collections.sort(L);&#x2F;&#x2F;将容器内元素排序（默认升序）</span><br><span class="line">        System.out.println(L);</span><br><span class="line">        System.out.println(Collections.binarySearch(L,&quot;a5&quot;));&#x2F;&#x2F;采用折半查找方法查找元素（前提该元素必须是升序排列，否则查找会失败）</span><br><span class="line">        System.out.println(Collections.binarySearch(L,&quot;a7&quot;));</span><br><span class="line">        Collections.reverse(L);</span><br><span class="line">        System.out.println(L);</span><br><span class="line">        System.out.println(Collections.binarySearch(L,&quot;a5&quot;));</span><br><span class="line">        Collections.fill(L,&quot;222&quot;);&#x2F;&#x2F;以222重写容器内所有元素</span><br><span class="line">        System.out.println(L);</span><br><span class="line">        System.out.println(Collections.binarySearch(L,&quot;a5&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">编译时会产生和泛型相关的错误，可忽略，之后会解决</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>Comparable接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class student&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    public student(int id,String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.id&#x3D;id;</span><br><span class="line">        this.name&#x3D;name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return id+&quot; &quot;+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class test18&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        List L&#x3D;new LinkedList();</span><br><span class="line">        L.add(new student(1000,&quot;张三&quot;));</span><br><span class="line">        L.add(new student(1004,&quot;张四&quot;));</span><br><span class="line">        L.add(new student(1002,&quot;张五&quot;));</span><br><span class="line">        L.add(new student(1001,&quot;张六&quot;));</span><br><span class="line">        Collections.sort(L);&#x2F;&#x2F;用户自定义类未制定比较标准，故无法比较</span><br><span class="line">        System.out.println(L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*会报错，由于无比较标准*&#x2F;</span><br><span class="line"></span><br><span class="line">正确如下：</span><br><span class="line">import java.util.*;</span><br><span class="line">class student implements Comparable&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    public student(int id,String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.id&#x3D;id;</span><br><span class="line">        this.name&#x3D;name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return id+&quot; &quot;+name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int compareTo(Object o)</span><br><span class="line">    &#123;</span><br><span class="line">        student st&#x3D;(student)o;&#x2F;&#x2F;多态父类引用无法调用子类特有的方法和属性，只能调用子类从父类继承过来的方法和属</span><br><span class="line">                             &#x2F;&#x2F;性，如果想要调用子类特有的方法和属性，则需对父类引用进行强制类型转换</span><br><span class="line">        return this.id-st.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class test18&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        List L&#x3D;new LinkedList();</span><br><span class="line">        L.add(new student(1000,&quot;张三&quot;));</span><br><span class="line">        L.add(new student(1004,&quot;张四&quot;));</span><br><span class="line">        L.add(new student(1002,&quot;张五&quot;));</span><br><span class="line">        L.add(new student(1001,&quot;张六&quot;));</span><br><span class="line">        Collections.sort(L);&#x2F;&#x2F;虽然是用户自定义类但制定了比较标准，故可比较；sort方法自动调用了类student的</span><br><span class="line">                            &#x2F;&#x2F;CompareTo方法</span><br><span class="line">        System.out.println(L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*凡是需要排序的类（基本数据类型和String类除外）都须考虑实现Comparable接口并重写其compareTo方法以制定比较标准*&#x2F;</span><br></pre></td></tr></table></figure>

<p>set容器元素重复出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class student&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    public student(int id,String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.id&#x3D;id;</span><br><span class="line">        this.name&#x3D;name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return id+&quot; &quot;+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class test19&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Set s&#x3D;new HashSet();</span><br><span class="line">        s.add(new student(1000,&quot;张三&quot;));</span><br><span class="line">        s.add(new student(1001,&quot;李四&quot;));</span><br><span class="line">        s.add(new student(1002,&quot;王五&quot;));</span><br><span class="line">        s.add(new student(1002,&quot;王五&quot;));</span><br><span class="line">        System.out.println(s);&#x2F;&#x2F;set内元素无序，故输出元素无序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*未做处理，故有重复元素出现*&#x2F;</span><br></pre></td></tr></table></figure>
<p>set元素重复问题处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class student&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    public student(int id,String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.id&#x3D;id;</span><br><span class="line">        this.name&#x3D;name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return id+&quot; &quot;+name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int hashCode()&#123;</span><br><span class="line">        return new String(id+name).hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean equals(Object o)</span><br><span class="line">    &#123;</span><br><span class="line">        student st&#x3D; (student)o;</span><br><span class="line">        return st.id&#x3D;&#x3D;this.id&amp;&amp;st.name&#x3D;&#x3D;this.name;</span><br><span class="line">    &#125; </span><br><span class="line">    &#x2F;&#x2F;子类重写父类方法，访问权限不能低于父类，抛出范围不能大于父类</span><br><span class="line">    &#x2F;&#x2F;hashCode方法和equals方法继承自Object类</span><br><span class="line">&#125;</span><br><span class="line">public class test19&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Set s&#x3D;new HashSet();</span><br><span class="line">        s.add(new student(1000,&quot;张三&quot;));</span><br><span class="line">        s.add(new student(1001,&quot;李四&quot;));</span><br><span class="line">        s.add(new student(1002,&quot;王五&quot;));</span><br><span class="line">        s.add(new student(1002,&quot;王五&quot;));</span><br><span class="line">        System.out.println(s);&#x2F;&#x2F;set内元素无序，故输出元素无序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;我们必须同时重写equals方法和hashcode方法才可解决set容器内元素重复问题</span><br></pre></td></tr></table></figure>
<p>重写hashcode方法重要性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class A&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public A(int id)&#123;</span><br><span class="line">        this.id&#x3D;id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public B(int id)&#123;</span><br><span class="line">        this.id&#x3D;id;</span><br><span class="line">    &#125;</span><br><span class="line">    public int hashCode()&#123;</span><br><span class="line">        return new Integer(id).hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class test20&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;new A(1).hashCode()&#x3D;&quot;+new A(1).hashCode());</span><br><span class="line">        System.out.println(&quot;new A(1).hashCode()&#x3D;&quot;+new A(1).hashCode());</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;new Integer(1).hashCode()&#x3D;&quot;+new Integer(1).hashCode());</span><br><span class="line">        System.out.println(&quot;new Integer(1).hashCode()&#x3D;&quot;+new Integer(1).hashCode());</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;new String(\&quot;哈哈\&quot;).hashCode()&#x3D;&quot;+new String(&quot;哈哈&quot;).hashCode());</span><br><span class="line">        System.out.println(&quot;new String(\&quot;哈哈\&quot;).hashCode()&#x3D;&quot;+new String(&quot;哈哈&quot;).hashCode());</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;\&quot;哈哈\&quot;.hashCode()&#x3D;&quot;+(&quot;哈哈&quot;).hashCode());</span><br><span class="line">        System.out.println(&quot;\&quot;哈哈\&quot;.hashCode()&#x3D;&quot;+(&quot;哈哈&quot;).hashCode());</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;new B(1).hashCode()&#x3D;&quot;+new B(1).hashCode());</span><br><span class="line">        System.out.println(&quot;new B(1).hashCode()&#x3D;&quot;+new B(1).hashCode());</span><br><span class="line">        System.out.println();</span><br><span class="line">        Integer it1&#x3D;new Integer(1);</span><br><span class="line">        Integer it2&#x3D;new Integer(1);</span><br><span class="line">        System.out.println(it1&#x3D;&#x3D;it2);</span><br><span class="line">        System.out.println(it2.equals(it2));</span><br><span class="line">        System.out.println(it1.hashCode()&#x3D;&#x3D;it2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">new A(1).hashCode()&#x3D;366712642</span><br><span class="line">new A(1).hashCode()&#x3D;1829164700</span><br><span class="line"></span><br><span class="line">new Integer(1).hashCode()&#x3D;1</span><br><span class="line">new Integer(1).hashCode()&#x3D;1</span><br><span class="line"></span><br><span class="line">new String(&quot;哈哈&quot;).hashCode()&#x3D;694528</span><br><span class="line">new String(&quot;哈哈&quot;).hashCode()&#x3D;694528</span><br><span class="line"></span><br><span class="line">&quot;哈哈&quot;.hashCode()&#x3D;694528</span><br><span class="line">&quot;哈哈&quot;.hashCode()&#x3D;694528</span><br><span class="line"></span><br><span class="line">new B(1).hashCode()&#x3D;1</span><br><span class="line">new B(1).hashCode()&#x3D;1</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>String和Integer这些Java自带的类都重写了hashCode方法，如果Integer和String new出的对象内容相同则这些对象的<br>hashCode返回值是相同的，尽管他们占用不同的内存；<br>用户自定义的类如本程序的A类，即便内容相同hashCode返回值也不同，因为未重写hashCode方法；<br>如果希望自己定义的类对象占用内存不同但内容相同，返回相同的hashCode方法则程序员必须手动重写hashCode方法如本程序的B类；</p>
<p>为什么set（以hashset为实现类）中必须重写hashCode方法和equals方法？<br>假定有一个对象aa，要放在set容器中（以hashset为实现类）<br>存放原理：<br>我们先根据aa的hashCode方法按照某中算法找到它在set容器中的位置，后存放进去(实际上并未放入容器中，而是放入后面的<br>线性链表中)，这是调用equals方法判断它与后面链表中的元素是否存在重复，若重复则不存放，不重复则存放；<br>set容器并未存放对象本身，它存放的是存储地址；<br>所以我们必须重写这些方法；<br>如果只重写了hashCode方法而未重写equals方法，同样会造成重复，因为未重写equals方法，equals判断的是内存地址的异同<br>而非内容的异同；如容器内存入两个两个内容相同的类A对象;<br>如果只重写了equals方法而未重写hashCode方法，同样会造成重复,如存入两个内容相同的类A对象（找到的存储地址不同）；</p>
<p>放在什么容器中需要重写hashCode方法和equals方法？<br>hashset、hashmap。hashtable需全部重写；<br>Treeset、Treemap无需重写，因为该树有序的（我们必须指定比较标准因此这两个实现类造出的容器内的类对象必须实现<br>Comparable接口并重写compareTo方法）</p>
<p>如何重写hashCode方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode()</span><br><span class="line">&#123;</span><br><span class="line">    return 当前类中基本类型对象的hashCode方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterator遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class point&#123;</span><br><span class="line">   private int i;</span><br><span class="line">   private int j;</span><br><span class="line">   public point(int j,int i)</span><br><span class="line">   &#123;</span><br><span class="line">       this.i&#x3D;i;</span><br><span class="line">       this.j&#x3D;j;</span><br><span class="line">   &#125;</span><br><span class="line">   public String toString()&#123;</span><br><span class="line">       return &quot;[&quot;+i+&quot;,&quot;+j+&quot;]&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class test21&#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">       ArrayList aa&#x3D;new ArrayList();</span><br><span class="line">       aa.add(&quot;one&quot;);</span><br><span class="line">       aa.add(22);</span><br><span class="line">       aa.add(new point(1,1));</span><br><span class="line">       System.out.println(&quot;容器a1的元素为：&quot;);</span><br><span class="line">       showcollection(aa);</span><br><span class="line">       HashSet hs&#x3D;new HashSet();</span><br><span class="line">       hs.add(22);</span><br><span class="line">       hs.add(new point(1,2));</span><br><span class="line">       System.out.println(&quot;容器hs的元素为：&quot;);</span><br><span class="line">       showcollection(hs);</span><br><span class="line">   &#125;</span><br><span class="line">   static void showcollection(Collection e)&#123;</span><br><span class="line">       Iterator it&#x3D;e.iterator();</span><br><span class="line">       while(it.hasNext())</span><br><span class="line">       &#123;</span><br><span class="line">           System.out.println(it.next());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;容器中所有继承了Collection接口的类都默认实现了Iterator中的三个方法</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2021/03/12/Java%E5%AE%B9%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%BC%94%E7%A4%BA%E5%92%8C%E5%86%85%E5%AE%B9%E8%A1%A5%E5%85%85/" data-id="ckm6c07sl0000tgvp1ttw3d77" data-title="Java容器程序演示和内容补充" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java容器概述2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/11/Java%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B02/" class="article-date">
  <time class="dt-published" datetime="2021-03-11T14:04:42.000Z" itemprop="datePublished">2021-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/11/Java%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B02/">Java容器概述2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>java之自动装箱：<br>容器中存入的是一定是对象，不能放孤立的值，容器内如果放孤立的值，它会被转化成相应的对象；<br>预备知识：<br>对于任意的类A，设有一个A类对象aa<br>若System.out.println(aa);则等价于System.out.println(aa.toString());<br>Object类中含有hashcode方法、equals方法、toString方法等<br>Java中所有类默认继承Object类<br>建议所有子类重写toString方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection c&#x3D;new Arraylist();&#x2F;&#x2F;运用多态</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">System.out.println(c);&#x2F;&#x2F;等价于[调用第一个元素方法的toString方法，调用第二个元素方法的toString方法，调用第三个元素方法的toString方法，...]</span><br></pre></td></tr></table></figure>
<p>容器之Collections：<br>Collection接口的实现类;<br>Arraylist、Linkedlist本身并未提供排序、查找等功能，这些方法是由collections类实现的，该类中含有很多Public<br>static方法，可直接对collection接口的实现类进行操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">collections类中提供了一些方法：</span><br><span class="line">Public static void sort(List);&#x2F;&#x2F;排序（默认升序）</span><br><span class="line">Public static void shuffle(List);&#x2F;&#x2F;随机排列</span><br><span class="line">Public static void reverse(List);&#x2F;&#x2F;逆序排列</span><br><span class="line">Public static void fill(List,Object);&#x2F;&#x2F;用一个特定的对象重写容器中的每个元素</span><br><span class="line">Public static void copy(List dest,List src);&#x2F;&#x2F;将src容器内容拷贝到dest容器中</span><br><span class="line">Public static int bindarysearch();&#x2F;&#x2F;对于升序的List容器，采用折半查找特定的对象；折半查找必须是升序的;</span><br></pre></td></tr></table></figure>
<p>容器之Comparable接口：<br>为什么使用Compareable接口？<br>基本类型数据和String类型数据，它们彼此间的比较标准Java本身已经制定好了<br>用户自定义类对象之间比较的标准，Java本身未提供;所以一个容器中含有用户自定义数据时，并且我们需要对容器中的元素进<br>行排序和查找，我们必须指定元素与元素之间的比较标准，凡是需要排序的场合均可考虑实现Cpmparable接口;<br>Comparable接口介绍:<br>该接口中只有一个方法int compareTo(Object o);返回一个负整数，零或正整数，因为该对象小于，等于或大于指定对象。<br>实现了Comparable接口的实现类通过重写compareTo方法从而确定该类对象的排列方式；</p>
<p>容器之Iterator接口：<br>要想遍历容器中的所有元素，判断是否存在下一元素，返回下一个元素都是非常麻烦的事，这些复杂容易出现错误的操作在Java<br>中用hasNext()、Next()、remove()这三个方法表示，这三个方法的具体实现sun公司已经设计好了，并且API中所有继承了<br>Collection的类都已经实现了Iterator接口中的这三个方法；<br>Iterator接口以统一的方式对各种不同集合中的元素进行遍历；<br>实现了Iterator接口的对象又称迭代器，利用该对象可方便地对容器中的元素进行遍历；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator中常用方法：</span><br><span class="line">Boolean hasNext();&#x2F;&#x2F;用于判断游标右边是否存在元素；</span><br><span class="line">Object next();&#x2F;&#x2F;返回游标右边的元素，然后游标移向下一个位置</span><br><span class="line">void remove();&#x2F;&#x2F;删除最近返回的元素，在调用remove之前我们必须调用一次Next方法，调用一次next方法只能调用一次</span><br><span class="line">remove方法</span><br></pre></td></tr></table></figure>
<p>容器之treeset：<br>treeset是一个有序的集合，treeset内元素按照升序排列，因此treeset元素必须实现Comparable接口<br>所有可以排序的类都应实现Comparable接口<br>hashset性能通常优于treeset，我们通常使用hashset，在我们需要排序时才使用hashset</p>
<p>预备知识：<br>散列码：Object中的hashcode方法会返回该对象内存真实地址的整数化表示，这个形象的又不是真实地址的整数值就是散列码，又称哈希码;<br>哈希码与地址有关，但不一定是地址;<br>哈希表：哈希表不止存储需要保存的数据，更会存储该数据的主键；实际是先保留主键，然后哈希表会根据主键某种算法自动计算出以当前主键为主键的数据的hashcode，然后根据hashcode计算出数据存储位置然后将该数据存进去；<br>哈希表又称散列表<br>哈希表中不允许存在重复的键<br>哈希表主要是为了提高数据的存储速度和查找速度而设计的；<br>几乎所有的哈希表都会产生哈希冲突<br>Java中利用桶来解决哈希冲突<br>哈希冲突指关键字映射的地址相同导致前面的数据被覆盖；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2021/03/11/Java%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B02/" data-id="ckm4y2bbv0000x8vp5soghlab" data-title="Java容器概述2" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java容器概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/10/java%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-10T03:12:09.000Z" itemprop="datePublished">2021-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/10/java%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/">java容器概述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>容器是一个集合，用于存放对象；<br>如果一个类用于存放其它的类对象，那么该类叫做容器;</p>
<p>为什么需要容器？<br>容器弥补了数组的缺陷：数组长度难以扩充、元素类型必须相同；<br>如A[] aa=new A[10],表示分配了一个数组，每个元素都是A类对象的引用，若想要扩充数组长度为15，不能再原数组内存后面直接追加内存，必须另外分配一块内存为15，然后利用System.arraycopy方法将原数组内容拷贝到新的内存中，耗时又耗内存；</p>
<p>容器与现实的关系：<br>容器是将若干用途、性质相近或相同的数据组合在一起的整体；</p>
<p>数学上集合分为三类:<br>集（set，不允许重复、不区分元素顺序）；<br>列表（List,区分元素顺序、允许重复）；<br>映射（map，保存成对的键值信息，映射不能包含重复的键，每个键最多映射一个值）；<br>Java设计了三种接口类型分别是set、List、Map来对应数学上三种集合;<br>Map存事物信息时不仅要存入事物的基本信息（值），更要存入事物最独特的特征（键）；</p>
<p>容器以接口为核心组合在一起；<br>容器API位于Java.util包中<br>容器框架<br>        1.《interface》collection:《interface》set（实现类：Hashset、Treeset）、《interface》list（实现类Arraylist、Linkedlist)<br>        2.《interface》map（实现类：Hashmap、Treemap）</p>
<p>容器之collection：<br>collection接口定义了存取一组对象的方法，其子接口分别定义了存储方式：set中数据对象无序不可重复;list中数据对象有序可重复;<br>map接口定义了“键-值映射对”方法;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">collection中方法介绍：</span><br><span class="line">int size();&#x2F;&#x2F;返回collection容器中元素的个数</span><br><span class="line">Boolean Isempty();&#x2F;&#x2F;判断容器是否为空</span><br><span class="line">Boolean containAll(Collection e);&#x2F;&#x2F;判断当前集合是否包含容器e中的全部元素</span><br><span class="line">Iterator iterator();&#x2F;&#x2F;返回能够遍历当前容器所有元素的迭代器；</span><br><span class="line">Object[] toArray();&#x2F;&#x2F;容器不是数组，不能通过下标方式访问容器中的元素；调用此方法，返回其包含此容器全部元素的数组</span><br><span class="line">&#x2F;&#x2F;如Object[] ob&#x3D;a.toArray();&#x2F;&#x2F;a为容器</span><br><span class="line">    System.out.println(ob[2]);</span><br><span class="line">Boolean add(Object e);&#x2F;&#x2F;将对象e添加到集合中去</span><br><span class="line">Boolean remove(Object o)&#x2F;&#x2F;删除某个元素</span><br><span class="line">Boolean addAll(Collection e);&#x2F;&#x2F;将容器e中全部元素添加到当前容器中</span><br><span class="line">Boolean removeAll(Collection e);&#x2F;&#x2F;将当前容器中包含在容器e中的元素全部删除</span><br><span class="line">void clear();&#x2F;&#x2F;将当前容器中所有元素都清除</span><br><span class="line">Boolean equals(Object);&#x2F;&#x2F;继承自Java.lang中的Object类</span><br><span class="line">int hashcode()；&#x2F;&#x2F;继承自Java.lang中的Object类，返回内存地址十六进制的哈希码表示</span><br></pre></td></tr></table></figure>
<p>容器之List:<br>List表示的是线性结构而不是链表；<br>List继承自接口Collection；<br>实现了list接口的容器类中元素有顺序可重复；<br>List容器中的元素都对应一个整数器的序号，记录其在容器中的位置，可以根据序号存取容器的元素<br>Java提供的List实现类 ：Arraylist、Linkedlist等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java中list接口提供了一些方法：</span><br><span class="line">Object get(int index);&#x2F;&#x2F;找到列表中位置为index的元素</span><br><span class="line">Object set(int index,Object element);&#x2F;&#x2F;将列表中下标为index的元素替换为element</span><br><span class="line">Object add(int index,Object O);&#x2F;&#x2F;将O添加到下标为index的位置</span><br><span class="line">Object remove(int index);&#x2F;&#x2F;删除下标为index的元素；</span><br><span class="line">int indexof(Object O);&#x2F;&#x2F;找到O元素的下标</span><br><span class="line">int lastindexof(Object O);&#x2F;&#x2F;找到最后O元素的下标</span><br></pre></td></tr></table></figure>
<p>set接口中无set（）get（）方法，因为set接口是无序的，不存在元素具体位置这个概念；<br>Arraylist和Linkedlist比较:<br>都实现了List接口中的方法但内部实现不同；<br>Arraylist底层采用数组实现，Linkedlist底层一般以双向链表实现；<br>Arraylist查找存取速度快，插入删除速度慢；Linkedlist查找存取速度慢，插入删除速度快；</p>
<p>容器之set:<br>set继承自Collection<br>实现了set类的容器内元素无序且不能重复；<br>set接口实现类：Treeset、Hashset等<br>我们需要同时重写默认父类Object中的Hashcode方法和equals方法来使set容器中元素不可重复；<br>如果我们定义了set接口而未全部重写它的hashcode方法和equals方法，则set容器中的元素就会重复；</p>
<p>容器之map接口:<br>Map（映射）是一种将键对象和值对象进行映射的集合，它的每个元素都包含一对键对象和值对象；<br>向Map中加入元素时，必须提供一对键对象和值对象，从Map集合中检索元素时，只要给出键对象，就能返回相应的值对象；<br>接口Map提供了根据关键字找出对应值的方法：Object get(Object key)//会返回值对象<br>接口Map提供了设置键值对的方法：Object put(Object key,Object value)；//根据Key值计算出存储位置然后将Value存入<br>存入此位置，如果该位置原来已有元素则覆盖它；该方法返回覆盖之前的元素对象的值，如果以前此位置为空则返回null;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map方法（并非全部）：</span><br><span class="line">Set keySet()&#x2F;&#x2F;返回此地图中键的set集合;</span><br><span class="line">boolean containsKey(Object key);&#x2F;&#x2F;如果此映射包含指定键，则返回true ；</span><br><span class="line">boolean containsValue(Object value);&#x2F;&#x2F;如果此映射将一个或多个键映射到指定的值，则返回true;</span><br><span class="line">int size();&#x2F;&#x2F;返回此地图中键值映射的数量。</span><br><span class="line">boolean isEmpty()如果此地图不包含键值映射，则返回 true;</span><br><span class="line">Object remove(Object key);&#x2F;&#x2F;如果存在（从可选的操作），从该地图中删除一个键的映射;</span><br><span class="line">void putAll(Map m);&#x2F;&#x2F;将指定地图的所有映射复制到此映射（可选操作）;</span><br><span class="line">void clear();&#x2F;&#x2F;从该地图中删除所有的映射（可选操作）;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2021/03/10/java%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/" data-id="ckm2v9qeb0000t4vpgjj03cdc" data-title="java容器概述" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-排序之插入排序" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/09/%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" class="article-date">
  <time class="dt-published" datetime="2021-03-09T08:03:00.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/09/%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">排序之插入排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Insertion&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] arr&#x3D;&#123;1,5,2,8,3,9,4,6,5,10&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    static void sort(int[] arr)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;arr.length-1;i++)&#123;           </span><br><span class="line">            for(int j&#x3D;i+1;j&gt;0&amp;&amp;arr[j-1]&gt;arr[j];j--)&#x2F;&#x2F;前面有序，故可这样写</span><br><span class="line">               swap(arr,j-1,j);</span><br><span class="line">           System.out.println(&quot;经过&quot;+(i+1)+&quot;次排序后为:&quot;);</span><br><span class="line">           print(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    static void print(int[] arr)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;arr.length;i++)</span><br><span class="line">           System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">           System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    static void swap(int[] arr,int i,int j)&#123;</span><br><span class="line">        int temp&#x3D;arr[i];</span><br><span class="line">        arr[i]&#x3D;arr[j];</span><br><span class="line">        arr[j]&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用swap：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Insertion_sort&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] arr&#x3D;&#123;1,5,2,8,3,9,4,6,5,10&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    static void sort(int[] arr)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">            int temp&#x3D;arr[i+1];           </span><br><span class="line">            int j;</span><br><span class="line">            for(j&#x3D;i+1;j&gt;0&amp;&amp;arr[j-1]&gt;temp;j--)</span><br><span class="line">                arr[j]&#x3D;arr[j-1];</span><br><span class="line">             arr[j]&#x3D;temp;</span><br><span class="line">           System.out.println(&quot;经过&quot;+(i+1)+&quot;次排序后为:&quot;);</span><br><span class="line">           print(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static void print(int[] arr)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;arr.length;i++)</span><br><span class="line">           System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">           System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    static void swap(int[] arr,int i,int j)&#123;</span><br><span class="line">        int temp&#x3D;arr[i];</span><br><span class="line">        arr[i]&#x3D;arr[j];</span><br><span class="line">        arr[j]&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2021/03/09/%E6%8E%92%E5%BA%8F%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" data-id="ckm1qsovx0000j0vp6zw7d4s6" data-title="排序之插入排序" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-排序之冒泡排序" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/09/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" class="article-date">
  <time class="dt-published" datetime="2021-03-09T07:55:06.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/09/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">排序之冒泡排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Bubble_sort&#123;</span><br><span class="line">    public static void main( String[] args)&#123;</span><br><span class="line">        int[] arr&#x3D;&#123;1,5,2,8,3,9,4,6,5,10&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    static void sort(int[] arr)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">           for(int j&#x3D;0;j&lt;arr.length-1-i;j++)</span><br><span class="line">               if(arr[j+1]&lt;arr[j])</span><br><span class="line">                 swap(arr,j,j+1);</span><br><span class="line">           System.out.println(&quot;经过&quot;+(i+1)+&quot;次排序后为:&quot;);</span><br><span class="line">           print(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    static void print(int[] arr)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;arr.length;i++)</span><br><span class="line">           System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">           System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    static void swap(int[] arr,int i,int j)&#123;</span><br><span class="line">        int temp&#x3D;arr[i];</span><br><span class="line">        arr[i]&#x3D;arr[j];</span><br><span class="line">        arr[j]&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int j&#x3D;0;j&lt;arr.length-1-i;j++)</span><br><span class="line">    if(arr[j+1]&lt;arr[j])</span><br><span class="line">       swap(arr,j,j+1);</span><br><span class="line">改为</span><br><span class="line">for(int j&#x3D;0;j&lt;arr.length-1-i&amp;&amp;arr[j+1]&lt;arr[j];j++)</span><br><span class="line">    swap(arr,j,j+1);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2021/03/09/%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" data-id="ckm1q62k50000csvp2ftqb1uo" data-title="排序之冒泡排序" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何写算法？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/08/%E5%A6%82%E4%BD%95%E5%86%99%E7%AE%97%E6%B3%95%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2021-03-08T14:13:56.000Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/08/%E5%A6%82%E4%BD%95%E5%86%99%E7%AE%97%E6%B3%95%EF%BC%9F/">如何写算法？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3>（1）由简单到复杂</h3>
验证一步走一步
多打印中间结果
<h3>（2）先局部后整体</h3>
没思路先细分
<h3>（3）先粗糙后精细</h3>
变量更名
语句合并
边界处理
      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2021/03/08/%E5%A6%82%E4%BD%95%E5%86%99%E7%AE%97%E6%B3%95%EF%BC%9F/" data-id="ckm0o5kx90000pgvp1n6odp98" data-title="如何写算法？" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-排序之选择排序法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/08/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-03-08T13:31:29.000Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/08/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/">排序之选择排序法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>选择排序<br>n个元素经过数次比较后找到最小值位置（开始时最小值位置为0），将其与第一个元素互换，再对n-1个元素选择排序；每<br>次确定一个最小值；<br>程序：对九个数选择排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Slection_sort&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] arr&#x3D;&#123;4,5,8,1,3,9,2,7,6&#125;;</span><br><span class="line">        int minpos;&#x2F;&#x2F;定义一个变量，该变量存放最小值下标</span><br><span class="line">        for(int i&#x3D;0;i&lt;arr.length-1;i++)&#x2F;&#x2F;需要经过length-1次遍历，每次遍历找出一个最小值</span><br><span class="line">        &#123;</span><br><span class="line">            minpos&#x3D;i;</span><br><span class="line">            for(int j&#x3D;i+1;j&lt;arr.length;j++)</span><br><span class="line">                 minpos&#x3D;arr[j]&lt;arr[minpos]?j:minpos;&#x2F;&#x2F;找出每次的最小值的下标</span><br><span class="line">            swap(arr,minpos,i);&#x2F;&#x2F;互换最小值和i位置</span><br><span class="line">            System.out.println(&quot;minpos&#x3D;&quot;+minpos);</span><br><span class="line">            System.out.println(&quot;经过&quot;+(i+1)+&quot;次排序为：&quot;);</span><br><span class="line">            print(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void swap(int[] arr,int minpos,int i )</span><br><span class="line">    &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        temp&#x3D;arr[minpos];</span><br><span class="line">        arr[minpos]&#x3D;arr[i];</span><br><span class="line">        arr[i]&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void print(int[] arr)</span><br><span class="line">    &#123;</span><br><span class="line">      for(int i&#x3D;0;i&lt;arr.length;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">      &#125;    </span><br><span class="line">      System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2021/03/08/%E6%8E%92%E5%BA%8F%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95/" data-id="ckm0nzwhd0000l0vp6l8086x0" data-title="排序之选择排序法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java-io程序演示" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/07/java-io%E7%A8%8B%E5%BA%8F%E6%BC%94%E7%A4%BA/" class="article-date">
  <time class="dt-published" datetime="2021-03-07T03:36:19.000Z" itemprop="datePublished">2021-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/07/java-io%E7%A8%8B%E5%BA%8F%E6%BC%94%E7%A4%BA/">java io程序演示</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>(1)将当前程序显示到屏幕上（文件流）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;&#x2F;&#x2F;导入java .io包来使用相关流</span><br><span class="line">public class test1&#123;</span><br><span class="line">    public static void main(String[] args)throws Exception&#123;</span><br><span class="line">        FileReader fr&#x3D;new FileReader(&quot;E:\\javaworkspace\\流\\test1.java&quot;);&#x2F;&#x2F;调用FileReader的构造方法将fr与该文件关联起来，该构造方法会抛出FileNotFoundException</span><br><span class="line">        int ch&#x3D;fr.read();&#x2F;&#x2F;调用fr的read（）方法读取一个字符，它返回的是该字符的整数表示，它会抛出IOException</span><br><span class="line">        while(-1!&#x3D;ch)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.printf(&quot;%c&quot;,ch);&#x2F;&#x2F;将该字符输出</span><br><span class="line">            ch&#x3D;fr.read();&#x2F;&#x2F;读取下一个字符并返回其整数形式，若读至末尾，则返回-1</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;哈哈&quot;);</span><br><span class="line">        fr.close();&#x2F;&#x2F;调用fr的close方法，关闭该流并释放与该流相关的所有系统资源，它会抛出IOException</span><br><span class="line">        System.out.printf(&quot;哈哈&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)将当前程序写入到一个文件中去（文件流）（该文件无需创建，只要写清存放路径即可）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;&#x2F;&#x2F;导入java. io包使用相关流</span><br><span class="line">public class test2&#123;</span><br><span class="line">    public static void main(String[] args)throws Exception&#123;</span><br><span class="line">        FileReader fr&#x3D;new FileReader(&quot;E:\\javaworkspace\\流\\test2.java&quot;);&#x2F;&#x2F;调用其构造方法，使其与文件相关联，会抛出FileNotFoundException</span><br><span class="line">        FileWriter fw&#x3D;new FileWriter(&quot;E:\\javaworkspace\\流\\1.txt&quot;);&#x2F;&#x2F;调用其构造方法，使其与文件相关联，会抛出FileNotFoundException</span><br><span class="line">        char[] buf&#x3D;new char[1024];&#x2F;&#x2F;构造一个字符数组用作中间媒介</span><br><span class="line">        int len&#x3D;fr.read(buf);&#x2F;&#x2F;将从E:\\javaworkspace\\流\\test2.java读取的一系列字符存入字符数组buf并返回存入的字符数，如果读至末尾则返回-1;会抛出IOException</span><br><span class="line">        while(-1!&#x3D;len)</span><br><span class="line">        &#123;</span><br><span class="line">            fw.write(buf,0,len);&#x2F;&#x2F;将buf数组中的从下标为0开始的len个字符写入到输出流中;会抛出IOException</span><br><span class="line">            len&#x3D;fr.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();&#x2F;&#x2F;清空缓冲区内存，将停留在缓冲区中的数据全部压入到预定目的地;会抛出IOException</span><br><span class="line">        fr.close();&#x2F;&#x2F;关闭该流并释放与之相关联的所有系统资源;会抛出IOException</span><br><span class="line">      fw.close();&#x2F;&#x2F;关闭该流并释放与之相关联的所有系统资源;会抛出IOException    </span><br><span class="line">        System.out.println(&quot;哈哈&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)用缓冲流将当前程序写入到一个文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;&#x2F;&#x2F;导入java. io包使用相关流</span><br><span class="line">public class test3&#123;</span><br><span class="line">    public static void main(String[] args)throws Exception&#123;</span><br><span class="line">        BufferedReader br&#x3D;new BufferedReader(new FileReader(&quot;E:\\javaworkspace\\流\\test3.java&quot;));&#x2F;&#x2F;调用其构造方法创建一个缓冲区，使其与文件相关联，会抛出FileNotFoundException;同时运用了多态</span><br><span class="line">        BufferedWriter bw&#x3D;new BufferedWriter(new FileWriter(&quot;E:\\javaworkspace\\流\\2.txt&quot;));&#x2F;&#x2F;调用其构造方法创建一个缓冲区，使其与文件相关联，会抛出FileNotFoundException;同时运用了多态</span><br><span class="line">        char[] buf&#x3D;new char[1024];&#x2F;&#x2F;构造一个字符数组用作中间媒介</span><br><span class="line">        int len&#x3D;br.read(buf);&#x2F;&#x2F;将从E:\\javaworkspace\\流\\test3.java读取的一系列字符存入字符数组buf并返回存入的字符数，如果读至末尾则返回-1;会抛出IOException</span><br><span class="line">        while(-1!&#x3D;len)</span><br><span class="line">        &#123;</span><br><span class="line">            bw.write(buf,0,len);&#x2F;&#x2F;将buf数组中的从下标为0开始的len个字符写入到输出流中;会抛出IOException</span><br><span class="line">            len&#x3D;br.read(buf);</span><br><span class="line">        &#125;</span><br><span class="line">        bw.flush();&#x2F;&#x2F;清空缓冲区内存，将停留在缓冲区中的数据全部压入到预定目的地;会抛出IOException</span><br><span class="line">        br.close();&#x2F;&#x2F;关闭该流并释放与之相关联的所有系统资源;会抛出IOException</span><br><span class="line">        bw.close();&#x2F;&#x2F;关闭该流并释放与之相关联的所有系统资源;会抛出IOException</span><br><span class="line">        System.out.println(&quot;哈哈&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)用缓冲流将当前程序写入到一个文件当中，并用try…catch处理异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test4&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        BufferedReader br&#x3D;null;</span><br><span class="line">        BufferedWriter bw&#x3D;null;</span><br><span class="line">        String str&#x3D;null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            br&#x3D;new BufferedReader(new FileReader(&quot;E:\\javaworkspace\\流\\test4.java&quot;));</span><br><span class="line">            bw&#x3D;new BufferedWriter(new FileWriter(&quot;E:\\javaworkspace\\流\\3.txt&quot;));</span><br><span class="line">            str&#x3D;br.readLine();&#x2F;&#x2F;调用BufferedReader中的readLine方法用于读取一行字符；遇到回车符会停止读取，并丢弃读取到的换行符</span><br><span class="line">            while(null!&#x3D;str)</span><br><span class="line">            &#123;</span><br><span class="line">                bw.write(str);&#x2F;&#x2F;调用BufferedWriter中的write(String str)方法将字符串写入到输出流中</span><br><span class="line">                bw.newLine();&#x2F;&#x2F;调用BufferedWriter中的newLine方法用于写入一个回车符</span><br><span class="line">                str&#x3D;br.readLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(FileNotFoundException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;文件未找到&quot;);</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                bw.flush();</span><br><span class="line">                bw.close();</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">            catch(Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.exit(-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）将long类型数据写入Byte类型数组中并将它解读出来（数据流）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test5&#123;</span><br><span class="line">    public static void main(String[] args)throws Exception&#123;</span><br><span class="line">        ByteArrayOutputStream baos&#x3D;new ByteArrayOutputStream();&#x2F;&#x2F;创建一个字节数组输出流</span><br><span class="line">        DataOutputStream dos&#x3D;new DataOutputStream(baos);&#x2F;&#x2F;调用DataOutputStream构造方法创建数据输出流，以将数据写入底层输出流；运用了多态</span><br><span class="line">        long i&#x3D;12345L;</span><br><span class="line">        dos.writeLong(i);&#x2F;&#x2F;将long类型数据写入底层输出流</span><br><span class="line">        byte[] buf&#x3D;baos.toByteArray();&#x2F;&#x2F;创建一个新分配的字节数组,其大小是此输出流的当前大小，缓冲区的有效内容已被复制到其中。 </span><br><span class="line">        ByteArrayInputStream bais&#x3D;new ByteArrayInputStream(buf);&#x2F;&#x2F;使用buf创建一个字节数组输入流</span><br><span class="line">        DataInputStream dis&#x3D;new DataInputStream(bais);&#x2F;&#x2F;调用DataIntputStream构造方法创建数据输入流，将位于底层输入流的数据读取出来</span><br><span class="line">        long m&#x3D;dis.readLong();&#x2F;&#x2F;将数据读取出来并返回读取出来的值</span><br><span class="line">        System.out.println(m);</span><br><span class="line">        dos.flush();</span><br><span class="line">        dos.close();</span><br><span class="line">        dis.close();</span><br><span class="line">        baos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(6)从键盘输入字符串直接赋给String对象(转换流、缓冲流)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class test6&#123;</span><br><span class="line">    public static void main(String[] args)throws Exception&#123;</span><br><span class="line">        BufferedReader br&#x3D;new BufferedReader(new InputStreamReader(System.in));&#x2F;&#x2F;调用InputStreamReader将System.in标准字节输入流转化为字符输入流</span><br><span class="line">        String str&#x3D;br.readLine();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(7)比较Print流和数据输出流的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import  java.io.*;</span><br><span class="line">public class test7&#123;</span><br><span class="line">  public static void main(String[] args)throws Exception&#123;</span><br><span class="line">    DataOutputStream dos&#x3D;new DataOutputStream(new FileOutputStream(&quot;E:\\javaworkspace\\流\\4.txt&quot;));&#x2F;&#x2F;创建一个数据输出流，将数据写入底层输出流；运用多态</span><br><span class="line">    long m&#x3D;1234567;</span><br><span class="line">    dos.writeLong(m);&#x2F;&#x2F;将m的二进制数据写入到相应的输出流中</span><br><span class="line">    PrintStream ps&#x3D;new PrintStream(new FileOutputStream(&quot;E:\\javaworkspace\\流\\5.txt&quot;));&#x2F;&#x2F;创建一个输出流，将数据打印到底层输出流中</span><br><span class="line">    ps.println(1234567);&#x2F;&#x2F;将1234567的字符串格式打印到底层输出流中</span><br><span class="line">    dos.close();</span><br><span class="line">    ps.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(8)输入输出重定向(print流)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;&#x2F;&#x2F;java.util包中包含Scanner类</span><br><span class="line">public class test8&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        PrintStream psOut&#x3D;null;</span><br><span class="line">        PrintStream psErr&#x3D;null;</span><br><span class="line">        Scanner sc&#x3D;null; </span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            psOut&#x3D;new PrintStream(&quot;E:\\javaworkspace\\流\\Out.txt&quot;);</span><br><span class="line">            psErr&#x3D;new PrintStream(&quot;E:\\javaworkspace\\流\\Err.txt&quot;);</span><br><span class="line">            sc&#x3D;new Scanner (System.in);&#x2F;&#x2F;System.in是标准的输入流，表示从键盘输入</span><br><span class="line">            System.setOut(psOut);&#x2F;&#x2F;调用System类的静态方法setOut重新分配“标准”输出流，将默认在显示器上输出改为在psOut所关联的文件输出</span><br><span class="line">            System.setErr(psErr);&#x2F;&#x2F;调用System类的静态方法seErr重新分配“标准”错误输出流，将默认在显示器上输出改为在psErr所关联的文件输出</span><br><span class="line">            while(true)</span><br><span class="line">            &#123;</span><br><span class="line">            psOut.println(sc.nextInt());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.err.println(&quot;错误信息为：&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(9)对象的序列化(Object流和文件流)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">class student implements Serializable&#x2F;&#x2F;Serializable接口为标识接口（空接口），表示该类对象允许被序列化；任何对象要想被序列化，必须实现Serializable接口</span><br><span class="line">&#123;</span><br><span class="line">    public int age;</span><br><span class="line">    public String name;</span><br><span class="line">    transient int id&#x3D;0;&#x2F;&#x2F;被transient修饰的成员变量无法被序列化</span><br><span class="line">    public student(int age,String name,int id)&#123;</span><br><span class="line">        this.age&#x3D;age;</span><br><span class="line">        this.name&#x3D;name;</span><br><span class="line">        this.id&#x3D;id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class test9&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ObjectInputStream ois&#x3D;null;</span><br><span class="line">        ObjectOutputStream oos&#x3D;null;</span><br><span class="line">        student st&#x3D;null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            oos&#x3D;new ObjectOutputStream(new FileOutputStream(&quot;E:\\javaworkspace\\流\\6.txt&quot;));</span><br><span class="line">            ois&#x3D;new ObjectInputStream(new FileInputStream(&quot;E:\\javaworkspace\\流\\6.txt&quot;));</span><br><span class="line">            oos.writeObject(new student (19,&quot;张三&quot;,2020));&#x2F;&#x2F;将对象写入到底层输出流中</span><br><span class="line">            st&#x3D;(student) ois.readObject();&#x2F;&#x2F;读取对象并强制类型转换</span><br><span class="line">            System.out.println(st.name+&quot; &quot;+st.id+&quot; &quot;+st.age);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(FileNotFoundException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;文件未找到&quot;);</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        catch(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">            oos.close();</span><br><span class="line">            ois.close();</span><br><span class="line">            &#125;</span><br><span class="line">            catch(Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.exit(-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2021/03/07/java-io%E7%A8%8B%E5%BA%8F%E6%BC%94%E7%A4%BA/" data-id="cklylt0qj0000egvpbkhrdpmm" data-title="java io程序演示" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java-io概述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/06/java-io%E6%A6%82%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2021-03-06T14:47:23.000Z" itemprop="datePublished">2021-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/06/java-io%E6%A6%82%E8%BF%B0/">java io概述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>流<br>定义：流就是程序和设备之间有用于数据传输的管道，这根管道管道上有很多按钮，不同的按钮可以实现不同的功能；</p>
<p>分类：<br>Java.io包中定义多个流类型来实现输入输出功能：<br>（1）按数据流的方向不同可以分为输入流和输出流；<br>（2）按照数据处理的单位可以分为字符流和字节流；<br>（3）按照功能不同可以分为节点流（原始流）和处理流（包裹流）；<br>注：处理流就是包裹在原始节点上的流相当于包裹在管道上的管道；</p>
<p>我们主要学习以下几种流：<br>（1）四大基本流<br>J2SDK所提供的所有流类型分别继承以下四种抽象流类型<br>inputstream（字节流和输入流）、outputstream（字节流和输出流）、reader（字符流和输入流）、writer（字符流和输出流）<br>通常我们使用的它们的子类。<br>（2）文件流<br>通过文件流我们可以以字符或字节为单位将文件的内容读取或将内容写入文件中<br>分为：<br>字节流：FileInputstream、FileOutputstream<br>字符流: FileReader、FileWriter<br>(3)缓冲流<br>缓冲流是带有缓冲区的输入输出流；<br>缓冲流本身为处理流，不能单独存在，必须依附于节点流；<br>缓冲流作用：<br>1.可以显著减少我们对IO访问的次数，保护我们的硬盘；<br>2缓冲流要套接在相应的节点流上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法；<br>分类：<br>BufferedReader、BufferedWriter、BufferedInputstream、BufferedOutputstream<br>（4）数据流<br>它是以一种与机器无关的方式，将Java基本类型数据和string类型数据从输入流读取或写入到输入流；<br>分为：DataInputsream、DataOutputstream<br>(5)转换流<br>分为InputstreamReader（将Inputstream转换为Reader）、OutputstreamWriter（将Outputstream转换为Writer）<br>转换流为处理流，不能单独存在，必须依附相应的节点流<br>（6）print流<br>分为printWriter、printstream<br>print流的print方法可以写入所有基本类型数据的字符串形式表示<br>print流在基本输出流的基础上提供了增强的功能，可以方便的输出各种类型数据的格式化表示形式；<br>print流重载了print和println方法用于各种类型数据的格式化输出；<br>所谓格式化输出指的是将一个数据用其字符串格式输出；<br>printWriter和printstream区别：<br>作为处理流使用时，printstream只能封装Outputstream类型的字节流，而printWriter可封装Outputstream类型的字节流，<br>也可封装Writer类型的字符流；<br>printWriter中的println方法具有更好的跨平台性；<br>（7）object流<br>分为ObjectInputstream、Objectoutputstream<br>Object流用于对象的序列化；<br>对象的序列化是指将一个对象直接转化为字节流，然后将字节流直接写入到本地硬盘或网络中；<br>如果想将某个类对象序列化，则该类必须实现Serializable接口（该接口无任何方法，这种类型的接口被称为标识接口）；<br>如果一个类对象实现了Serializable接口潜在含义告诉编译器该类对象允许被序列化，若程序中已经存在序列该对象的代码，编<br>译器会自动处理来完成该对象的序列化；<br>如果一个类对象未实现Serializable接口，程序中存在序列该对象的代码，编译器会报错；<br>在Java中被transient修饰的成员变量在对象序列化时无法被序列化；<br>注：<br>（1）以stream结尾的流是字节流；<br>（2）以字节为单位读取数据<u>显示</u>时不能读取汉字否则会造成乱码；因为汉字的两个字节均包含有效信息，使用<br>Inputstream的read方法只能读取汉字的最后一个字节，这样解码时会出现错误；可以读取字母，虽然字母由两个字节存储，但<br>只有最后一个字节包含有效信息；<br>（3）字节流可以完成对各种信息的复制如文本、声音、视频、图片等，而字符流只能完成文本信息的复制；因为字节流无需解码<br>而字符流需要解码；<br>（4）对于输出的缓冲流，写入的数据会先存入缓冲区，使用flush方法可以清空缓冲区数据，将缓冲区数据全部压入目的地。只<br>有输出流有flush方法；<br>（5）BufferedReader中的readline方法用于读取一行字符串，遇到回车符会终止读取，并将读取到的回车符自动丢弃；<br>如果只输入回车，readline返回的是” “(空字符串)而不是null；如果想输入回车符，则调用BufferedWriter中的newline方法<br>（6）print流提供的打印方法不会抛出异常；<br>（7）DataOutputstream中的write方法是将数据的二进制数据写入文件；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://username.github.io/2021/03/06/java-io%E6%A6%82%E8%BF%B0/" data-id="cklxucpmp0000jkvpa9ub74h1" data-title="java io概述" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/11/%E6%8E%92%E5%BA%8F%E4%B9%8BBindarysort/">排序之Bindarysort</a>
          </li>
        
          <li>
            <a href="/2021/04/11/%E6%8E%92%E5%BA%8F%E4%B9%8BTimsort/">排序之Timsort</a>
          </li>
        
          <li>
            <a href="/2021/04/11/%E6%B5%85%E8%B0%88%E5%B7%A5%E4%B8%9A%E5%BF%AB%E6%8E%92/">浅谈工业快排</a>
          </li>
        
          <li>
            <a href="/2021/04/09/%E6%8E%92%E5%BA%8F%E4%B9%8B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">排序之计数排序</a>
          </li>
        
          <li>
            <a href="/2021/04/09/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%8F%8C%E8%BD%B4%E6%8E%92%E5%BA%8F/">快速排序之双轴排序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 omnisciencepeople<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>